import { useState, useCallback, useEffect } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { supabase } from '@/lib/supabase';
import { ChatMessage } from '@/types';
import { toast } from '@/hooks/use-toast';
import { useAuth } from '@/hooks/useAuth';
import { API_ENDPOINTS, API_AUTH } from '@/config';

export interface UseChatProps {
  sessionId?: string;
}

export const useChat = ({ sessionId: initialSessionId }: UseChatProps = {}) => {
  const { user } = useAuth();
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [sessionId, setSessionId] = useState<string>(initialSessionId || uuidv4());

  useEffect(() => {
    if (initialSessionId) {
      setSessionId(initialSessionId);
    } else {
      setMessages([]);
      setError(null);
      setLoading(false); 
      // A new sessionId is already generated by useState default for useChat instances without an initialSessionId.
    }
  }, [initialSessionId]);

  const fetchMessages = useCallback(async (sessionIdToFetch: string) => {
    if (!sessionIdToFetch) return;
    try {
      setLoading(true);
      setError(null);
      setMessages([]); 

      const { data, error: fetchError } = await supabase
        .from('messages')
        .select('*')
        .eq('session_id', sessionIdToFetch)
        .order('created_at', { ascending: true });

      if (fetchError) {
        throw fetchError;
      }

      if (!data || data.length === 0) {
        setMessages([]); 
        return;
      }

      const formattedMessages = data.map((item) => ({
        id: item.id,
        content: item.message.content,
        type: item.message.type,
        timestamp: item.created_at,
        user_id: item.user_id,
      }));

      setMessages(formattedMessages);
    } catch (err: any) {
      console.error('Error fetching messages:', err);
      setError(err.message);
      toast({
        title: 'Failed to load messages',
        description: err.message,
        variant: 'destructive',
      });
    } finally {
      setLoading(false);
    }
  }, [toast]); // supabase is stable, setMessages, setLoading, setError are stable

  const sendMessage = useCallback(async (
    content: string,
    isInitialGreeting: boolean = false,
    isHiddenFromDisplay: boolean = false 
  ) => {
    // If it's not an initial greeting and the content is empty, there's nothing to send or display.
    if (!isInitialGreeting && !content.trim()) {
      return;
    }

    if (!user) {
      console.log('User not authenticated, message cannot be sent.');
      toast({
        title: 'Not signed in',
        description: 'Sign in to send messages.',
        variant: 'destructive',
      });
      return;
    }

    // Add human message to UI only if not hidden and it's a displayable message
    if (!isHiddenFromDisplay) {
      if (!isInitialGreeting || content.trim() !== "") { // Original logic for displaying actual typed messages
        const userMessage: ChatMessage = {
          id: uuidv4(),
          content,
          type: 'human',
          timestamp: new Date().toISOString(),
          user_id: user.id, // user is checked above, so user.id is safe here
        };
        setMessages((prev) => [...prev, userMessage]);
      }
    }
    
    setLoading(true);
    setError(null);

    try {
      const requestId = uuidv4();
      const bodyPayload: {
        query: string;
        user_id: string;
        request_id: string;
        session_id: string;
        is_initial_greeting?: boolean;
      } = {
        query: content,
        user_id: user.id, // user is checked above
        request_id: requestId,
        session_id: sessionId,
      };

      if (isInitialGreeting) {
        bodyPayload.is_initial_greeting = true;
      }

      const response = await fetch(`${API_ENDPOINTS.mentorAgent}/api/pydantic-mentor-agent`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${API_AUTH.bearerToken}`,
        },
        body: JSON.stringify(bodyPayload),
      });

      if (!response.ok) {
         const errorData = await response.json().catch(() => ({}));
         throw new Error(errorData.data || `API request failed with status ${response.status}`);
      }

      const agentResponse = await response.json();

      if (!agentResponse.success) {
        throw new Error(agentResponse.data || 'Failed to get response from AI agent');
      }

      const aiMessage: ChatMessage = {
        id: uuidv4(),
        content: agentResponse.data,
        type: 'ai',
        timestamp: new Date().toISOString(),
        user_id: user.id, 
      };
      setMessages((prev) => [...prev, aiMessage]);

    } catch (err: any) {
      console.error('Error sending message:', err);
      setError(err.message);
      toast({
        title: 'Failed to send message',
        description: err.message,
        variant: 'destructive',
      });
    } finally {
      setLoading(false);
    }
  }, [user, sessionId, setMessages, setLoading, setError, toast]);

  const notifyAgentFileUploaded = useCallback(async (fileName: string) => {
    if (!user) {
      console.error('notifyAgentFileUploaded: User not authenticated.');
      toast({
        title: 'Not signed in',
        description: 'Authentication required to notify agent.',
        variant: 'destructive',
      });
      return;
    }

    setLoading(true); 
    setError(null);

    try {
      const requestId = uuidv4();
      const bodyPayload = {
        query: "", 
        user_id: user.id,
        request_id: requestId,
        session_id: sessionId,
        is_initial_greeting: false, 
        file_uploaded_name: fileName 
      };

      const response = await fetch(`${API_ENDPOINTS.mentorAgent}/api/pydantic-mentor-agent`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${API_AUTH.bearerToken}`,
        },
        body: JSON.stringify(bodyPayload),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.data || `API request failed for file notification with status ${response.status}`);
      }

      const agentResponse = await response.json();

      if (!agentResponse.success) {
        throw new Error(agentResponse.data || 'Agent failed to process file upload notification.');
      }

      if (agentResponse.data) {
        const aiMessage: ChatMessage = {
          id: uuidv4(),
          content: agentResponse.data,
          type: 'ai',
          timestamp: new Date().toISOString(),
          user_id: user.id, 
        };
        setMessages((prev) => [...prev, aiMessage]);
      }

    } catch (err: any) {
      console.error('Error in notifyAgentFileUploaded:', err);
      setError(err.message);
      toast({
        title: 'File Notification Failed',
        description: `Could not notify Kal about "${fileName}". ${err.message}`,
        variant: 'destructive',
      });
    } finally {
      setLoading(false);
    }
  }, [user, sessionId, setLoading, setError, setMessages, toast, API_ENDPOINTS.mentorAgent, API_AUTH.bearerToken]);


  const createNewChat = useCallback(async () => {
    console.log("useChat: createNewChat called");
    const newSessionId = uuidv4(); 
    setSessionId(newSessionId);    
    setMessages([]);               
    setError(null);
    
    if (!user) {
      console.error("User not available for initial greeting.");
      toast({ title: "Error", description: "Could not start new chat: User not found.", variant: "destructive" });
      return newSessionId; 
    }

    setLoading(true); 
    const requestId = `greeting-${Date.now()}-${Math.random().toString(36).substring(7)}`;
    const currentUserId = user.id;

    try {
      const response = await fetch(`${API_ENDPOINTS.mentorAgent}/api/pydantic-mentor-agent`, {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${API_AUTH.bearerToken}`
          },
          body: JSON.stringify({
              query: "",
              user_id: currentUserId,
              request_id: requestId,
              session_id: newSessionId, 
              is_initial_greeting: true
          })
      });

      if (!response.ok) {
          let errorData = { data: `Agent: Sorry, I had a little trouble starting up. (${response.status})` };
          try {
            errorData = await response.json();
          } catch(e) { /* Ignore if not JSON */ }
          console.error("Error fetching initial greeting:", errorData.data || response.statusText);
          throw new Error(errorData.data || `API Error: ${response.status}`);
      }

      const result = await response.json();

      if (result.success && result.data) {
          const aiGreetingMessage: ChatMessage = {
              id: uuidv4(), 
              content: result.data,
              type: 'ai',
              timestamp: new Date().toISOString(),
              user_id: currentUserId, 
          };
          setMessages([aiGreetingMessage]); 
      } else {
          console.error("Failed to get greeting from agent:", result.data);
          const fallbackGreeting: ChatMessage = {
              id: uuidv4(),
              content: "Agent: Hello! I'm ready to chat. (Fallback greeting)",
              type: 'ai',
              timestamp: new Date().toISOString(),
              user_id: currentUserId,
          };
          setMessages([fallbackGreeting]);
      }
    } catch (error: any) {
        console.error("Network error fetching initial greeting:", error);
        setError(error.message);
        const networkErrorGreeting: ChatMessage = {
            id: uuidv4(),
            content: "Agent: Oops, couldn't connect to say hi! Please check your connection.",
            type: 'ai',
            timestamp: new Date().toISOString(),
            user_id: currentUserId,
        };
        setMessages([networkErrorGreeting]);
        toast({
          title: 'Connection Issue',
          description: 'Could not get initial greeting from mentor.',
          variant: 'destructive',
        });
    } finally {
        setLoading(false);
    }
    return newSessionId; 
  }, [user, toast, setSessionId, setMessages, setError, setLoading, API_ENDPOINTS.mentorAgent, API_AUTH.bearerToken]);

  const loadChat = useCallback((id: string) => {
    setSessionId(id);
  }, [setSessionId]);

  return {
    messages,
    loading,
    error,
    sessionId, 
    sendMessage,
    notifyAgentFileUploaded,
    createNewChat,
    loadChat,
    fetchMessages,
  };
};
